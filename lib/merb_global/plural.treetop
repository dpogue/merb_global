grammar Plural
  rule expression
    logop
  end

  rule logop
    bitop '&&' logop {
      def to_lambda
        lambda {|n| bitop.to_lambda.call(n) && logop.to_lambda.call(n) ? 0 : 1}
      end
    }
    /
    bitop '||' bitop {
      def to_lambda
        lambda {|n| bitop.to_lambda.call(n) || logop.to_lambda.call(n) ? 0 : 1}
      end
    }
    /
    bitop
  end

  rule bitop
    equality '&' bitop {
      def to_lambda
        lambda {|n| equality.to_lambda.call(n) & bitop.to_lambda.call(n)}
      end
    }
    /
    equality '^' bitop {
      def to_lambda
        lambda {|n| equality.to_lambda.call(n) ^ bitop.to_lambda.call(n)}
      end
    }
    /
    equality '|' bitop {
      def to_lambda
        lambda {|n| equality.to_lambda.call(n) | bitop.to_lambda.call(n)}
      end
    }
    /
    equality
  end

  rule equality
    relation '==' equality {
      def to_lambda
        lambda do |n|
          relation.to_lambda.call(n) == equality.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    relation '!=' equality {
      def to_lambda
        lambda do |n|
          relation.to_lambda.call(n) != equality.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    relation
  end

  rule relation
    bitwise '<' relation {
      def to_lambda
        lambda do |n|
          bitwise.to_lambda.call(n) < relation.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    bitwise '<=' relation {
      def to_lambda
        lambda do |n|
          bitwise.to_lambda.call(n) <= relation.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    bitwise '>' relation {
      def to_lambda
        lambda do |n|
          bitwise.to_lambda.call(n) > relation.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    bitwise '>=' relation {
      def to_lambda
        lambda do |n|
          bitwise.to_lambda.call(n) >= relation.to_lambda.call(n) ? 0 : 1
        end
      end
    }
    /
    bitwise
  end

  rule bitwise
    addition '<<' bitwise {
      def to_lambda
        lambda {|n| addition.to_lambda.call(n) << bitwise.to_lambda.call(n)}
      end
    }
    /
    addition '>>' bitwise {
      def to_lambda
        lambda {|n| addition.to_lambda.call(n) >> bitwise.to_lambda.call(n)}
      end
    }
    /
    addition
  end

  rule addition
    multiplication '+' addition {
      def to_lambda
        lambda do |n|
          multiplication.to_lambda.call(n) + addition.to_lambda.call(n)
        end
      end
    }
    /
    multiplication '-' addition {
      def to_lambda
        lambda do |n|
          multiplication.to_lambda.call(n) - addition.to_lambda.call(n)
        end
      end
    }
    /
    multiplication
  end

  rule multiplication
    unary '*' multiplication {
      def to_lambda
        lambda {|n| unary.to_lambda.call(n) * multiplication.to_lambda.call(n)}
      end
    }
    /
    unary '/' multiplication {
      def to_lambda
        lambda {|n| unary.to_lambda.call(n) / multiplication.to_lambda.call(n)}
      end
    }
    /
    unary '%' multiplication {
      def to_lambda
      	lambda {|n| unary.to_lambda.call(n) % multiplication.to_lambda.call(n)}
      end
    }
    /
    unary
  end

  rule unary
    '+' base {
      def to_lambda
        base.to_lambda
      end
    }
    /
    '-' base {
      def to_lambda
        lambda {|n| -base.to_lambda.call(n)}
      end
    }
    /
    '!' base {
      def to_lambda
        lambda {|n| base.to_lambda.call(n) == 0 ? 1 : 0}
      end
    }
    /
    '~' base {
      def to_lambda
        lambda {|n| ~base.call(n)}
      end
    }
    /
    base
  end

  rule base
    '(' expression ')' {
      def to_lambda
        expression.to_lambda
      end
    }
    /
    'n' {
      def to_lambda
        lambda {|n| n}
      end
    }
    /
    [0-9]* {
      def to_lambda
        lambda {|n| text_value.to_i}
      end
    }
  end
end